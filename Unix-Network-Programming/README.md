# <Unix网络编程>

#### 写在前面
> 本书起始于读书任务，目的是强化网络编程基础，故本次使用选择阅读，有些章节工作相关性较低，选择跳过

## 第一章 简介
- 

## 第十五章 Unix域协议
> 1. 概述
> 2. Unix域套接字地址结构
> 3. socketpair函数
> 4. 套接字函数
> 5. Unix域字节流客户/服务器程序
> 6. Unix域数据报客户/服务器程序
> 7. 描述符传递
> 8. 接收发送者的凭证
> 9. 小结

- 定义
  - 不是一个实际的协议族，而是一种单个主机的通信方法。
  - 第二章介绍的进程间通信(IPC Inter-Progress Communication) ,实际上就是单个主机上的客户/服务器通信,Unix域协议也可以认为是IPC方法之一。本地IPC
- 提供两类套接字
  - 字节流套接字(类似TCP)
  - 数据报套接字(类似UDP)
- 为什么使用Unix域套接字
  1. 快 比TCP套接字快一倍
  2. 可用于同一主机不同进程间的传递描述符 (后面有例子)
  3. Unix域套接字把客户的凭证(用户id和组id)提供给服务器,从而可以提供额外的安全检查 (后面有例子)
- 协议地址
  - 普通文件系统中的路径名
  - ipv4协议地址由32位的地址和16位的端口组成
  - ipv6协议地址由128位的地址和16位端口号组成
  - 路径名不是普通的Unix文件,除非与Unix套接字关联,否则无法读写

- bind()
  - 

- socketpair //创建两个随后连接起来的套接字
  - socketpair(family int, type int, protocol int, sockfd [2]int)
  - 指定type为SOCK_STREAM 得到两个流管道,与调用pipe创建的普通unix管道类型,区别是全双工的

- 套接字函数
  1. 由bind创建的路径名默认访问权限是0777,并按照当前umask值修正
  2. Unix域套接字关联的路径名应该是一个绝对路径名。否则客户就必须跟服务器在同一个工作目录中。
  3. connect调用中指定的路径名必须是一个当前绑定在某个***打开***的Unix域套接字上,并且他们的套接字类型(***字节流或数据报***)也必须一致。所以有可能有以下出错的情况:
      - 路径名已存在却不是一个套接字
      - 路径名已存在也是一个套接字,不过没有与之关联的打开的描述符
      - 路径名已存在也是一个套接字,不过类型不相符合
  4. 调用connect连接一个Unix域套接字涉及的权限等同于调用open以只写方式访问相应的路径名
  5. Unix域字节流套接字类似TCP套接字: 都是为进程提供一个无记录边界的字节流接口
      - 无记录边界：上层传下来的是以bit流的形式传下来的,比如限定在一个固定数值的bits,到这个固定长度断一下,这就是无边界的。如果上层传下来的是一个完整的包的形式,比如有像固定的包头,CRC检验码,长度标志位等等这些信息的,打成一个包的形式发给下层的,这样的就是有边界的了。
  6. 对某个Unix域字节流套接字的connect调用发现监听这个套接字的队列已满,则立即返回一个ECONNREFUSED错误。这一点跟TCP套接字不同,TCP监听端会忽略新到达的SYN,TCP发起段会数次发送SYN重试
  7. Unix域数据报套接字类似于UDP套接字: 它们都提供一个保留记录边界的不可靠的数据报服务。
  8. 在未绑定的Unix域套接字发送数据报不会自动给这个套接字捆绑一个路径名,这一点不同于UDP套接字: 在未绑定的UDP套接字上发送数据报导致给这个套接字捆绑一个临时端口。这一点意味着除非数据报发送端已经捆绑了一个路径名到套接字,否则数据报接收端无法发回应答数据报。类似的,对于某个Unix域数据报套接字的connect调用不会给本套接字捆绑一个路径名,这一点不同于TCP和UDP